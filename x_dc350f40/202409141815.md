# Inspecting clang output

Suppose that you have a very inefficient tester for the Collatz conjecture that uses this function `f` to move forward
in the sequence:

```
long long unsigned int f(long long unsigned int x) {
  int x_mod_6 = x % 6;
  if ((x_mod_6 == 0) || (x_mod_6 == 2) || (x_mod_6 == 4)) {
    return x / 2;
  } else if ((x_mod_6 == 1) || (x_mod_6 == 3) || (x_mod_6 == 5)) {
    return 3 * x + 1;
  }
  return 3 * x + 1;
}
```

The `clang++` flag `-S` tells the compiler to output the assembler instructions:

```
% clang++ --std=c++20 -c collatz.cc -S
```

## No optimisation

Generating the instructions with `-O0` gives a faithful (and inefficient) implementation of `f`:

```
# %bb.0:
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset %rbp, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register %rbp
	movq	%rdi, -16(%rbp)
	movq	-16(%rbp), %rax
	movl	$6, %ecx
	xorl	%edx, %edx
                                        # kill: def $rdx killed $edx
	divq	%rcx
	movl	%edx, %eax
	movl	%eax, -20(%rbp)
	cmpl	$0, -20(%rbp)
	je	.LBB0_3
# %bb.1:
	cmpl	$2, -20(%rbp)
	je	.LBB0_3
# %bb.2:
	cmpl	$4, -20(%rbp)
	jne	.LBB0_4
.LBB0_3:
	movq	-16(%rbp), %rax
	shrq	%rax
	movq	%rax, -8(%rbp)
	jmp	.LBB0_10
.LBB0_4:
	cmpl	$1, -20(%rbp)
	je	.LBB0_7
# %bb.5:
	cmpl	$3, -20(%rbp)
	je	.LBB0_7
# %bb.6:
	cmpl	$5, -20(%rbp)
	jne	.LBB0_8
.LBB0_7:
	imulq	$3, -16(%rbp), %rax
	addq	$1, %rax
	movq	%rax, -8(%rbp)
	jmp	.LBB0_10
.LBB0_8:
	jmp	.LBB0_9
.LBB0_9:
	imulq	$3, -16(%rbp), %rax
	addq	$1, %rax
	movq	%rax, -8(%rbp)
.LBB0_10:
	movq	-8(%rbp), %rax
	popq	%rbp
	.cfi_def_cfa %rsp, 8
	retq
```

There is the even numbers branch:

```
	cmpl	$0, -20(%rbp)
	je	.LBB0_3
# %bb.1:
	cmpl	$2, -20(%rbp)
	je	.LBB0_3
# %bb.2:
	cmpl	$4, -20(%rbp)
	jne	.LBB0_4
.LBB0_3:
	movq	-16(%rbp), %rax
	shrq	%rax
	movq	%rax, -8(%rbp)
	jmp	.LBB0_10
```

and the odd numbers branch:

```
.LBB0_4:
	cmpl	$1, -20(%rbp)
	je	.LBB0_7
# %bb.5:
	cmpl	$3, -20(%rbp)
	je	.LBB0_7
# %bb.6:
	cmpl	$5, -20(%rbp)
	jne	.LBB0_8
.LBB0_7:
	imulq	$3, -16(%rbp), %rax
	addq	$1, %rax
	movq	%rax, -8(%rbp)
	jmp	.LBB0_10
```

and that jump to `.LBB0_8` that will never be taken.

## With optimisation

Same source file compiled with `-O3` shows a more reasonable implementation with no jumps and conditional moves instead:

```
# %bb.0:
	movabsq	$-6148914691236517205, %rcx     # imm = 0xAAAAAAAAAAAAAAAB
	movq	%rdi, %rax
	mulq	%rcx
	shrq	$2, %rdx
	addl	%edx, %edx
	leal	(%rdx,%rdx,2), %eax
	movl	%edi, %ecx
	subl	%eax, %ecx
	leaq	(%rdi,%rdi,2), %rax
	incq	%rax
	shrq	%rdi
	testb	$5, %cl
	cmoveq	%rdi, %rax
	cmpl	$4, %ecx
	cmoveq	%rdi, %rax
	retq
```
